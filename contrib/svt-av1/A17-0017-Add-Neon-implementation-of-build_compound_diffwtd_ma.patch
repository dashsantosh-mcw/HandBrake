From 5b828722be69152c8ad8df6f6b30856dca610924 Mon Sep 17 00:00:00 2001
From: Salome Thirot <salome.thirot@arm.com>
Date: Thu, 10 Oct 2024 17:02:27 +0100
Subject: [PATCH 17/56] Add Neon implementation of build_compound_diffwtd_mask

Port the libaom Neon implementation of
svt_av1_build_compound_diffwtd_mask and add the corresponding unit
tests.
---
 Source/Lib/ASM_NEON/CMakeLists.txt          |   1 +
 Source/Lib/ASM_NEON/inter_prediction_neon.c | 103 ++++++++++++++++++++
 Source/Lib/Codec/common_dsp_rtcd.c          |   2 +-
 Source/Lib/Codec/common_dsp_rtcd.h          |   2 +
 test/CompoundUtilTest.cc                    |   9 +-
 5 files changed, 115 insertions(+), 2 deletions(-)
 create mode 100644 Source/Lib/ASM_NEON/inter_prediction_neon.c

diff --git a/Source/Lib/ASM_NEON/CMakeLists.txt b/Source/Lib/ASM_NEON/CMakeLists.txt
index d3880460..a0573177 100644
--- a/Source/Lib/ASM_NEON/CMakeLists.txt
+++ b/Source/Lib/ASM_NEON/CMakeLists.txt
@@ -44,6 +44,7 @@ target_sources(
   PUBLIC highbd_pickrst_neon.c
   PUBLIC highbd_variance_neon.c
   PUBLIC highbd_wiener_convolve_neon.c
+  PUBLIC inter_prediction_neon.c
   PUBLIC intra_prediction_neon.c
   PUBLIC itx.S
   PUBLIC obmc_sad_neon.c
diff --git a/Source/Lib/ASM_NEON/inter_prediction_neon.c b/Source/Lib/ASM_NEON/inter_prediction_neon.c
new file mode 100644
index 00000000..3897a83b
--- /dev/null
+++ b/Source/Lib/ASM_NEON/inter_prediction_neon.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2018, Alliance for Open Media. All rights reserved.
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#include <arm_neon.h>
+#include <assert.h>
+#include <stdbool.h>
+
+#include "definitions.h"
+#include "common_dsp_rtcd.h"
+#include "mem_neon.h"
+#include "utility.h"
+
+static INLINE void diffwtd_mask_neon(uint8_t *mask, const bool inverse, const uint8_t *src0, int src0_stride,
+                                     const uint8_t *src1, int src1_stride, int h, int w) {
+    if (w >= 16) {
+        int i = 0;
+        do {
+            int j = 0;
+            do {
+                uint8x16_t s0 = vld1q_u8(src0 + j);
+                uint8x16_t s1 = vld1q_u8(src1 + j);
+
+                uint8x16_t diff = vshrq_n_u8(vabdq_u8(s0, s1), DIFF_FACTOR_LOG2);
+                uint8x16_t m;
+                if (inverse) {
+                    m = vqsubq_u8(vdupq_n_u8(64 - 38), diff); // Saturating to 0
+                } else {
+                    m = vminq_u8(vaddq_u8(diff, vdupq_n_u8(38)), vdupq_n_u8(64));
+                }
+
+                vst1q_u8(mask, m);
+
+                mask += 16;
+                j += 16;
+            } while (j < w);
+            src0 += src0_stride;
+            src1 += src1_stride;
+        } while (++i < h);
+    } else if (w == 8) {
+        int i = 0;
+        do {
+            uint8x16_t s0 = vcombine_u8(vld1_u8(src0), vld1_u8(src0 + src0_stride));
+            uint8x16_t s1 = vcombine_u8(vld1_u8(src1), vld1_u8(src1 + src0_stride));
+
+            uint8x16_t diff = vshrq_n_u8(vabdq_u8(s0, s1), DIFF_FACTOR_LOG2);
+            uint8x16_t m;
+            if (inverse) {
+                m = vqsubq_u8(vdupq_n_u8(64 - 38), diff); // Saturating to 0
+            } else {
+                m = vminq_u8(vaddq_u8(diff, vdupq_n_u8(38)), vdupq_n_u8(64));
+            }
+
+            vst1q_u8(mask, m);
+
+            mask += 16;
+            src0 += 2 * src0_stride;
+            src1 += 2 * src1_stride;
+            i += 2;
+        } while (i < h);
+    } else if (w == 4) {
+        int i = 0;
+        do {
+            uint8x16_t s0 = load_unaligned_u8q(src0, src0_stride);
+            uint8x16_t s1 = load_unaligned_u8q(src1, src1_stride);
+
+            uint8x16_t diff = vshrq_n_u8(vabdq_u8(s0, s1), DIFF_FACTOR_LOG2);
+            uint8x16_t m;
+            if (inverse) {
+                m = vqsubq_u8(vdupq_n_u8(64 - 38), diff); // Saturating to 0
+            } else {
+                m = vminq_u8(vaddq_u8(diff, vdupq_n_u8(38)), vdupq_n_u8(64));
+            }
+
+            vst1q_u8(mask, m);
+
+            mask += 16;
+            src0 += 4 * src0_stride;
+            src1 += 4 * src1_stride;
+            i += 4;
+        } while (i < h);
+    }
+}
+
+void svt_av1_build_compound_diffwtd_mask_neon(uint8_t *mask, DIFFWTD_MASK_TYPE mask_type, const uint8_t *src0,
+                                              int src0_stride, const uint8_t *src1, int src1_stride, int h, int w) {
+    assert(h % 4 == 0);
+    assert(w % 4 == 0);
+    assert(mask_type == DIFFWTD_38_INV || mask_type == DIFFWTD_38);
+
+    if (mask_type == DIFFWTD_38) {
+        diffwtd_mask_neon(mask, /*inverse=*/false, src0, src0_stride, src1, src1_stride, h, w);
+    } else { // mask_type == DIFFWTD_38_INV
+        diffwtd_mask_neon(mask, /*inverse=*/true, src0, src0_stride, src1, src1_stride, h, w);
+    }
+}
diff --git a/Source/Lib/Codec/common_dsp_rtcd.c b/Source/Lib/Codec/common_dsp_rtcd.c
index b101b15b..0818b07a 100644
--- a/Source/Lib/Codec/common_dsp_rtcd.c
+++ b/Source/Lib/Codec/common_dsp_rtcd.c
@@ -1077,7 +1077,7 @@ void svt_aom_setup_common_rtcd_internal(EbCpuFlags flags) {
     SET_NEON(svt_av1_jnt_convolve_y, svt_av1_jnt_convolve_y_c, svt_av1_jnt_convolve_y_neon);
     SET_NEON_NEON_DOTPROD_NEON_I8MM(svt_aom_convolve8_horiz, svt_aom_convolve8_horiz_c, svt_aom_convolve8_horiz_neon, svt_aom_convolve8_horiz_neon_dotprod, svt_aom_convolve8_horiz_neon_i8mm);
     SET_NEON_NEON_DOTPROD_NEON_I8MM(svt_aom_convolve8_vert, svt_aom_convolve8_vert_c, svt_aom_convolve8_vert_neon, svt_aom_convolve8_vert_neon_dotprod, svt_aom_convolve8_vert_neon_i8mm);
-    SET_ONLY_C(svt_av1_build_compound_diffwtd_mask, svt_av1_build_compound_diffwtd_mask_c);
+    SET_NEON(svt_av1_build_compound_diffwtd_mask, svt_av1_build_compound_diffwtd_mask_c, svt_av1_build_compound_diffwtd_mask_neon);
     SET_ONLY_C(svt_av1_build_compound_diffwtd_mask_highbd, svt_av1_build_compound_diffwtd_mask_highbd_c);
     SET_NEON_SVE(svt_av1_wedge_sse_from_residuals, svt_av1_wedge_sse_from_residuals_c, svt_av1_wedge_sse_from_residuals_neon, svt_av1_wedge_sse_from_residuals_sve);
     SET_NEON(svt_aom_subtract_block, svt_aom_subtract_block_c, svt_aom_subtract_block_neon);
diff --git a/Source/Lib/Codec/common_dsp_rtcd.h b/Source/Lib/Codec/common_dsp_rtcd.h
index 86beb125..7d6c9afc 100644
--- a/Source/Lib/Codec/common_dsp_rtcd.h
+++ b/Source/Lib/Codec/common_dsp_rtcd.h
@@ -1091,6 +1091,8 @@ extern "C" {
     #define svt_aom_hadamard_4x4 svt_aom_hadamard_4x4_c
 
 #ifdef ARCH_AARCH64
+    void svt_av1_build_compound_diffwtd_mask_neon(uint8_t *mask, DIFFWTD_MASK_TYPE mask_type, const uint8_t *src0, int src0_stride, const uint8_t *src1, int src1_stride, int h, int w);
+
     void svt_av1_convolve_2d_sr_neon(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t dst_stride, int32_t w, int32_t h, InterpFilterParams *filter_params_x, InterpFilterParams *filter_params_y, const int32_t subpel_x_q4, const int32_t subpel_y_q4, ConvolveParams *conv_params);
 
     void svt_av1_convolve_2d_sr_neon_dotprod(const uint8_t *src, int32_t src_stride, uint8_t *dst, int32_t dst_stride, int32_t w, int32_t h, InterpFilterParams *filter_params_x, InterpFilterParams *filter_params_y, const int32_t subpel_x_q4, const int32_t subpel_y_q4, ConvolveParams *conv_params);
diff --git a/test/CompoundUtilTest.cc b/test/CompoundUtilTest.cc
index dcc26259..7397f3f6 100644
--- a/test/CompoundUtilTest.cc
+++ b/test/CompoundUtilTest.cc
@@ -865,7 +865,6 @@ class BuildCompDiffwtdMaskTest
   private:
     SVTRandom rnd_;
 };
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(BuildCompDiffwtdMaskTest);
 
 TEST_P(BuildCompDiffwtdMaskTest, MatchTest) {
     run_test(DIFFWTD_38);
@@ -886,6 +885,14 @@ INSTANTIATE_TEST_SUITE_P(
         ::testing::Values(svt_av1_build_compound_diffwtd_mask_avx2)));
 #endif  // ARCH_X86_64
 
+#ifdef ARCH_AARCH64
+INSTANTIATE_TEST_SUITE_P(
+    NEON, BuildCompDiffwtdMaskTest,
+    ::testing::Combine(
+        ::testing::Range(BLOCK_4X4, BlockSizeS_ALL),
+        ::testing::Values(svt_av1_build_compound_diffwtd_mask_neon)));
+#endif  // ARCH_AARCH64
+
 typedef void (*BuildCompDiffwtdMaskedHighbdFunc)(
     uint8_t *mask, DIFFWTD_MASK_TYPE mask_type, const uint8_t *src0,
     int src0_stride, const uint8_t *src1, int src1_stride, int h, int w,
-- 
2.36.0.windows.1

