From a0c1bbb00f23a08ce8191cfd2875da0f57ccb737 Mon Sep 17 00:00:00 2001
From: hguermaz <hassen.guermazi@intel.com>
Date: Mon, 4 Nov 2024 10:10:17 -0800
Subject: [PATCH 41/56] Add a safeguard against using qm when lossless coding
 is used. Avoid checking on segment-id when segmentation is ON

---
 Source/Lib/Codec/entropy_coding.c      |  2 +-
 Source/Lib/Codec/full_loop.c           |  6 +++---
 Source/Lib/Codec/md_config_process.c   | 10 ++++------
 Source/Lib/Codec/mode_decision.c       | 18 +++++++++++++++---
 Source/Lib/Codec/mode_decision.h       |  3 +++
 Source/Lib/Codec/product_coding_loop.c | 13 +++++++------
 Source/Lib/Codec/rd_cost.c             |  2 +-
 Source/Lib/Codec/transforms.c          |  2 +-
 Source/Lib/Globals/enc_handle.c        |  7 ++++++-
 9 files changed, 41 insertions(+), 22 deletions(-)

diff --git a/Source/Lib/Codec/entropy_coding.c b/Source/Lib/Codec/entropy_coding.c
index 6bef0794..a2522aab 100644
--- a/Source/Lib/Codec/entropy_coding.c
+++ b/Source/Lib/Codec/entropy_coding.c
@@ -4531,7 +4531,7 @@ static EbErrorType av1_code_tx_size(FRAME_CONTEXT *ec_ctx, AomWriter *w, MacroBl
     //int segment_id = 0;// mbmi->segment_id;
     if (tx_mode == TX_MODE_SELECT && block_signals_txsize(bsize) &&
 #if FTR_LOSSLESS_SUPPORT
-        !(is_inter_tx && skip) && !pcs->lossless[segment_id]) {
+        !(is_inter_tx && skip) && !svt_av1_is_lossless_segment(pcs, segment_id)) {
 #else
         !(is_inter_tx && skip) /*&& !xd->lossless[segment_id]*/) {
 #endif
diff --git a/Source/Lib/Codec/full_loop.c b/Source/Lib/Codec/full_loop.c
index 05ede147..b388f444 100644
--- a/Source/Lib/Codec/full_loop.c
+++ b/Source/Lib/Codec/full_loop.c
@@ -1563,7 +1563,7 @@ uint8_t svt_aom_quantize_inv_quantize(PictureControlSet *pcs, ModeDecisionContex
 
     // If rdoq_level is specified in the command line instruction, set perform_rdoq accordingly.
 #if FTR_LOSSLESS_SUPPORT
-    perform_rdoq = !pcs->lossless[ctx->blk_ptr->segment_id] &&
+    perform_rdoq = !svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) &&
         ((ctx->mds_skip_rdoq == FALSE || is_encode_pass) && ctx->rdoq_level);
 #else
     perform_rdoq = ((ctx->mds_skip_rdoq == FALSE || is_encode_pass) && ctx->rdoq_level);
@@ -1709,7 +1709,7 @@ void svt_aom_inv_transform_recon_wrapper(uint8_t *pred_buffer, uint32_t pred_off
                                     component_type,
                                     eob,
 #if FTR_LOSSLESS_SUPPORT
-                                    pcs->lossless[ctx->blk_ptr->segment_id]);
+                                    svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id));
 #else
                                     0 /*lossless*/);
 #endif
@@ -1724,7 +1724,7 @@ void svt_aom_inv_transform_recon_wrapper(uint8_t *pred_buffer, uint32_t pred_off
                                         component_type,
                                         eob,
 #if FTR_LOSSLESS_SUPPORT
-                                        pcs->lossless[ctx->blk_ptr->segment_id]);
+                                        svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id));
 #else
                                         0 /*lossless*/);
 #endif
diff --git a/Source/Lib/Codec/md_config_process.c b/Source/Lib/Codec/md_config_process.c
index 8d517002..a22adbcf 100644
--- a/Source/Lib/Codec/md_config_process.c
+++ b/Source/Lib/Codec/md_config_process.c
@@ -591,12 +591,9 @@ void *svt_aom_mode_decision_configuration_kernel(void *input_ptr) {
         RateControlResults *rc_results = (RateControlResults *)rc_results_wrapper->object_ptr;
         PictureControlSet  *pcs        = (PictureControlSet *)rc_results->pcs_wrapper->object_ptr;
         SequenceControlSet *scs        = pcs->scs;
-#if FTR_LOSSLESS_SUPPORT
-        pcs->mimic_only_tx_4x4 = 0;
-#endif
-        pcs->min_me_clpx = 0;
-        pcs->max_me_clpx = 0;
-        pcs->avg_me_clpx = 0;
+        pcs->min_me_clpx               = 0;
+        pcs->max_me_clpx               = 0;
+        pcs->avg_me_clpx               = 0;
         if (pcs->slice_type != I_SLICE) {
             uint32_t b64_idx;
             uint64_t avg_me_clpx = 0;
@@ -899,6 +896,7 @@ void *svt_aom_mode_decision_configuration_kernel(void *input_ptr) {
         }
 
 #if FTR_LOSSLESS_SUPPORT // ---
+        pcs->mimic_only_tx_4x4 = 0;
         if (frm_hdr->segmentation_params.segmentation_enabled) {
             Bool has_lossless_segment = 0;
             // Loop through each segment to determine if it is coded losslessly
diff --git a/Source/Lib/Codec/mode_decision.c b/Source/Lib/Codec/mode_decision.c
index bb518fee..f8afd33a 100644
--- a/Source/Lib/Codec/mode_decision.c
+++ b/Source/Lib/Codec/mode_decision.c
@@ -40,6 +40,17 @@
     MULTI_LINE_MACRO_END
 
 #define SUPERRES_INVALID_STATE 0x7fffffff
+
+#if FTR_LOSSLESS_SUPPORT
+bool svt_av1_is_lossless_segment(PictureControlSet *pcs, int8_t segment_id) {
+    FrameHeader *frm_hdr = &pcs->ppcs->frm_hdr;
+    if (frm_hdr->segmentation_params.segmentation_enabled)
+        return pcs->lossless[segment_id];
+    else
+        return pcs->lossless[0];
+}
+#endif
+
 static Bool check_mv_validity(int16_t x_mv, int16_t y_mv, uint8_t need_shift) {
     MV mv;
     //go to 1/8th if input is 1/4pel
@@ -3921,7 +3932,7 @@ static void inject_intra_candidates(
                     frm_hdr->reduced_tx_set);
 
 #if FTR_LOSSLESS_SUPPORT
-                if (pcs->lossless[ctx->blk_ptr->segment_id] && cand_array[cand_total_cnt].transform_type_uv != DCT_DCT)
+                if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) && cand_array[cand_total_cnt].transform_type_uv != DCT_DCT)
                     continue;
 #endif
             cand_array[cand_total_cnt].ref_frame_type = INTRA_FRAME;
@@ -3977,7 +3988,7 @@ static void inject_filter_intra_candidates(
                     ctx->blk_geom->txsize_uv[0],
                     frm_hdr->reduced_tx_set);
 #if FTR_LOSSLESS_SUPPORT
-                if (pcs->lossless[ctx->blk_ptr->segment_id] && cand_array[cand_total_cnt].transform_type_uv != DCT_DCT)
+                if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) && cand_array[cand_total_cnt].transform_type_uv != DCT_DCT)
                     continue;
 #endif
             cand_array[cand_total_cnt].ref_frame_type = INTRA_FRAME;
@@ -4095,7 +4106,7 @@ void  inject_palette_candidates(
                 ctx->blk_geom->txsize_uv[0],
                 pcs->ppcs->frm_hdr.reduced_tx_set);
 #if FTR_LOSSLESS_SUPPORT
-            if (pcs->lossless[ctx->blk_ptr->segment_id] && cand_array[can_total_cnt].transform_type_uv != DCT_DCT)
+            if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) && cand_array[can_total_cnt].transform_type_uv != DCT_DCT)
                 continue;
 #endif
         cand_array[can_total_cnt].ref_frame_type = INTRA_FRAME;
@@ -5110,3 +5121,4 @@ uint64_t svt_spatial_full_distortion_ssim_kernel(uint8_t* input, uint32_t input_
 
     return spatial_distortion;
 }
+
diff --git a/Source/Lib/Codec/mode_decision.h b/Source/Lib/Codec/mode_decision.h
index ea93c90a..662e846c 100644
--- a/Source/Lib/Codec/mode_decision.h
+++ b/Source/Lib/Codec/mode_decision.h
@@ -238,6 +238,9 @@ extern MvReferenceFrame svt_get_ref_frame_type(uint8_t list, uint8_t ref_idx);
 int                     svt_aom_get_sad_per_bit(int qidx, EbBitDepth is_hbd);
 
 int svt_av1_allow_palette(int allow_palette, BlockSize bsize);
+#if FTR_LOSSLESS_SUPPORT
+bool svt_av1_is_lossless_segment(PictureControlSet *pcs, int8_t segment_id);
+#endif
 #ifdef __cplusplus
 }
 #endif
diff --git a/Source/Lib/Codec/product_coding_loop.c b/Source/Lib/Codec/product_coding_loop.c
index 0d35679e..c22e8725 100644
--- a/Source/Lib/Codec/product_coding_loop.c
+++ b/Source/Lib/Codec/product_coding_loop.c
@@ -6811,9 +6811,9 @@ static void md_stage_2(PictureControlSet *pcs, ModeDecisionContext *ctx, EbPictu
         ModeDecisionCandidate       *cand           = cand_bf->cand;
         ctx->mds_tx_size_mode                       = 0;
 #if FTR_LOSSLESS_SUPPORT
-        ctx->mds_txt_level = pcs->lossless[ctx->blk_ptr->segment_id] ? 0
-            : is_intra_mode(cand->pred_mode)                         ? ctx->txt_ctrls.enabled
-                                                                     : 0;
+        ctx->mds_txt_level = svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) ? 0
+            : is_intra_mode(cand->pred_mode)                                            ? ctx->txt_ctrls.enabled
+                                                                                        : 0;
 #else
         ctx->mds_txt_level = is_intra_mode(cand->pred_mode) ? ctx->txt_ctrls.enabled : 0;
 #endif
@@ -6938,7 +6938,7 @@ static void md_stage_3(PictureControlSet *pcs, ModeDecisionContext *ctx, EbPictu
 
         ctx->mds_tx_size_mode = ctx->txs_ctrls.enabled && (ctx->blk_geom->sq_size >= ctx->txs_ctrls.min_sq_size);
 #if FTR_LOSSLESS_SUPPORT
-        ctx->mds_txt_level = pcs->lossless[ctx->blk_ptr->segment_id] ? 0 : ctx->txt_ctrls.enabled;
+        ctx->mds_txt_level = svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) ? 0 : ctx->txt_ctrls.enabled;
 #else
         ctx->mds_txt_level = ctx->txt_ctrls.enabled;
 #endif
@@ -7228,7 +7228,8 @@ static void search_best_mds3_uv_mode(PictureControlSet *pcs, EbPictureBufferDesc
         cand_array[uv_mode_total_count].transform_type_uv         = svt_aom_get_intra_uv_tx_type(
             cand_array[uv_mode_total_count].intra_chroma_mode, ctx->blk_geom->txsize_uv[0], frm_hdr->reduced_tx_set);
 #if FTR_LOSSLESS_SUPPORT // fix
-        if (pcs->lossless[ctx->blk_ptr->segment_id] && cand_array[uv_mode_total_count].transform_type_uv != DCT_DCT)
+        if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) &&
+            cand_array[uv_mode_total_count].transform_type_uv != DCT_DCT)
             continue;
 #endif
         uv_mode_total_count++;
@@ -7429,7 +7430,7 @@ static void search_best_independent_uv_mode(PictureControlSet *pcs, EbPictureBuf
                 cand_array[uv_mode_total_count].transform_type_uv          = svt_aom_get_intra_uv_tx_type(
                     uv_mode, ctx->blk_geom->txsize_uv[0], frm_hdr->reduced_tx_set);
 #if FTR_LOSSLESS_SUPPORT // fix
-                if (pcs->lossless[ctx->blk_ptr->segment_id] &&
+                if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id) &&
                     cand_array[uv_mode_total_count].transform_type_uv != DCT_DCT)
                     continue;
 #endif
diff --git a/Source/Lib/Codec/rd_cost.c b/Source/Lib/Codec/rd_cost.c
index 84a89481..024de31f 100644
--- a/Source/Lib/Codec/rd_cost.c
+++ b/Source/Lib/Codec/rd_cost.c
@@ -1899,7 +1899,7 @@ uint64_t svt_aom_tx_size_bits(MdRateEstimationContext *md_rate_est_ctx, MacroBlo
     int      is_inter_tx = is_inter_block(&mbmi->block_mi);
     if (tx_mode == TX_MODE_SELECT && block_signals_txsize(bsize) &&
 #if FTR_LOSSLESS_SUPPORT
-        !(is_inter_tx && skip) && !pcs->lossless[segment_id]) {
+        !(is_inter_tx && skip) && !svt_av1_is_lossless_segment(pcs, segment_id)) {
 #else
         !(is_inter_tx && skip) /*&& !xd->lossless[segment_id]*/) {
 #endif
diff --git a/Source/Lib/Codec/transforms.c b/Source/Lib/Codec/transforms.c
index 73fc5881..c749981d 100644
--- a/Source/Lib/Codec/transforms.c
+++ b/Source/Lib/Codec/transforms.c
@@ -3173,7 +3173,7 @@ EbErrorType svt_aom_estimate_transform(int16_t *residual_buffer, uint32_t residu
     (void)component_type;
 
 #if FTR_LOSSLESS_SUPPORT
-    if (pcs->lossless[ctx->blk_ptr->segment_id]) {
+    if (svt_av1_is_lossless_segment(pcs, ctx->blk_ptr->segment_id)) {
         assert(transform_type == DCT_DCT);
         int32_t dst[16];
 
diff --git a/Source/Lib/Globals/enc_handle.c b/Source/Lib/Globals/enc_handle.c
index af03bdc0..b7327b35 100644
--- a/Source/Lib/Globals/enc_handle.c
+++ b/Source/Lib/Globals/enc_handle.c
@@ -5008,7 +5008,12 @@ static void copy_api_from_app(
         SVT_WARN("Quantization matrices will be forced off since both min and max quant matrix levels are set to 15\n");
         scs->static_config.enable_qm = 0;
     }
-
+#if FTR_LOSSLESS_SUPPORT
+    if (scs->static_config.enable_qm && scs->static_config.lossless) {
+        SVT_WARN("Quantization matrices will be forced off since lossless coding is applied\n");
+        scs->static_config.enable_qm = 0;
+    }
+#endif
     scs->static_config.startup_mg_size = config_struct->startup_mg_size;
     scs->static_config.enable_roi_map = config_struct->enable_roi_map;
 
-- 
2.36.0.windows.1

