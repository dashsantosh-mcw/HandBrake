From dda33a04053ec0fdcb5a3e761d6d2bb663b990d9 Mon Sep 17 00:00:00 2001
From: stickz <stickman002@mail.com>
Date: Sat, 12 Oct 2024 15:59:50 -0400
Subject: [PATCH 15/56] Cleanup various code

This merge request cleans up various code across the SVT-AV1 project.

common_dsp_rtcd.c: Use SQR macro and remove variable to allow for loop vectorization.

enc_inter_prediction.c:
Use SQR macro and remove variable to allow for loop vectorization.

entropy_coding.c: Use ternary operators for returns.

full_loop.c: Return difference squared in one step without requiring int64_t variable.

k_means_template.h:
Use SQR macro and remove variable to allow for loop vectorization.
Repeat loops to avoid checking the value of the svt_memcpy pointer each iteration.

product_coding_loop.c:
Optimize variable datatypes.
Use array to avoid decision structure in for loop.
Unroll the two iteration CFL_SIGNS for loop to allow for additional optimizations.

rc_process.c: Use ternary operators for return types and variable setting.

temporal_filtering.c: Use SQR macro and remove variable to allow for loop vectorization.
---
 Source/Lib/Codec/common_dsp_rtcd.c      |   6 +-
 Source/Lib/Codec/enc_inter_prediction.c |  12 +--
 Source/Lib/Codec/entropy_coding.c       |  10 +-
 Source/Lib/Codec/full_loop.c            |   3 +-
 Source/Lib/Codec/k_means_template.h     |  72 ++++++++-----
 Source/Lib/Codec/product_coding_loop.c  | 136 ++++++++++++------------
 Source/Lib/Codec/rc_process.c           |  22 ++--
 Source/Lib/Codec/temporal_filtering.c   |  10 +-
 8 files changed, 132 insertions(+), 139 deletions(-)

diff --git a/Source/Lib/Codec/common_dsp_rtcd.c b/Source/Lib/Codec/common_dsp_rtcd.c
index a0727961..b101b15b 100644
--- a/Source/Lib/Codec/common_dsp_rtcd.c
+++ b/Source/Lib/Codec/common_dsp_rtcd.c
@@ -22,6 +22,7 @@
 #include "common_dsp_rtcd.h"
 #include "pic_operators.h"
 #include "pack_unpack_c.h"
+#include "utility.h"
 
 #if defined ARCH_X86_64
 // for svt_aom_get_cpu_flags
@@ -83,9 +84,8 @@ int64_t svt_av1_block_error_c(const TranLow *coeff, const TranLow *dqcoeff,
   int64_t error = 0, sqcoeff = 0;
 
   for (i = 0; i < block_size; i++) {
-    const int diff = coeff[i] - dqcoeff[i];
-    error += diff * diff;
-    sqcoeff += coeff[i] * coeff[i];
+    error += SQR(coeff[i] - dqcoeff[i]);
+    sqcoeff += SQR(coeff[i]);
   }
 
   *ssz = sqcoeff;
diff --git a/Source/Lib/Codec/enc_inter_prediction.c b/Source/Lib/Codec/enc_inter_prediction.c
index 4b3ffcee..1e500827 100644
--- a/Source/Lib/Codec/enc_inter_prediction.c
+++ b/Source/Lib/Codec/enc_inter_prediction.c
@@ -565,11 +565,7 @@ int64_t svt_aom_highbd_sse_c(const uint8_t *a8, int a_stride, const uint8_t *b8,
     uint16_t *a   = (uint16_t *)a8; //CONVERT_TO_SHORTPTR(a8);
     uint16_t *b   = (uint16_t *)b8; //CONVERT_TO_SHORTPTR(b8);
     for (y = 0; y < height; y++) {
-        for (x = 0; x < width; x++) {
-            const int32_t diff = (int32_t)(a[x]) - (int32_t)(b[x]);
-            sse += diff * diff;
-        }
-
+        for (x = 0; x < width; x++) { sse += SQR((int32_t)(a[x]) - (int32_t)(b[x])); }
         a += a_stride;
         b += b_stride;
     }
@@ -581,11 +577,7 @@ int64_t svt_aom_sse_c(const uint8_t *a, int a_stride, const uint8_t *b, int b_st
     int64_t sse = 0;
 
     for (y = 0; y < height; y++) {
-        for (x = 0; x < width; x++) {
-            const int32_t diff = abs(a[x] - b[x]);
-            sse += diff * diff;
-        }
-
+        for (x = 0; x < width; x++) { sse += SQR(a[x] - b[x]); }
         a += a_stride;
         b += b_stride;
     }
diff --git a/Source/Lib/Codec/entropy_coding.c b/Source/Lib/Codec/entropy_coding.c
index 725ff48a..754978c5 100644
--- a/Source/Lib/Codec/entropy_coding.c
+++ b/Source/Lib/Codec/entropy_coding.c
@@ -4668,18 +4668,12 @@ int svt_av1_neg_interleave(int x, int ref, int max) {
         return -x + max - 1;
     if (2 * ref < max) {
         if (abs(diff) <= ref) {
-            if (diff > 0)
-                return (diff << 1) - 1;
-            else
-                return ((-diff) << 1);
+            return diff > 0 ? (diff << 1) - 1 : ((-diff) << 1);
         }
         return x;
     } else {
         if (abs(diff) < (max - ref)) {
-            if (diff > 0)
-                return (diff << 1) - 1;
-            else
-                return ((-diff) << 1);
+            return diff > 0 ? (diff << 1) - 1 : ((-diff) << 1);
         }
         return (max - x) - 1;
     }
diff --git a/Source/Lib/Codec/full_loop.c b/Source/Lib/Codec/full_loop.c
index 0ff9acc9..becb8f25 100644
--- a/Source/Lib/Codec/full_loop.c
+++ b/Source/Lib/Codec/full_loop.c
@@ -756,8 +756,7 @@ static INLINE int get_coeff_cost_general(int is_last, int ci, TranLow abs_qc, in
     return cost;
 }
 static INLINE int64_t get_coeff_dist(TranLow tcoeff, TranLow dqcoeff, int shift) {
-    const int64_t diff = ((int64_t)tcoeff - dqcoeff) * (int64_t)(1lu << shift);
-    return diff * diff;
+    return SQR(((int64_t)tcoeff - dqcoeff) * (int64_t)(1lu << shift));
 }
 static INLINE void get_qc_dqc_low(TranLow abs_qc, int sign, int dqv, int shift, TranLow *qc_low, TranLow *dqc_low) {
     TranLow abs_qc_low = abs_qc - 1;
diff --git a/Source/Lib/Codec/k_means_template.h b/Source/Lib/Codec/k_means_template.h
index 7afca3d6..cba04e9a 100644
--- a/Source/Lib/Codec/k_means_template.h
+++ b/Source/Lib/Codec/k_means_template.h
@@ -12,6 +12,7 @@
 #include <assert.h>
 #include <stdint.h>
 #include <string.h>
+#include "utility.h"
 
 #ifndef AV1_K_MEANS_DIM
 #error "This template requires AV1_K_MEANS_DIM to be defined"
@@ -22,10 +23,7 @@
 
 static INLINE int RENAME(calc_dist)(const int *p1, const int *p2) {
     int dist = 0;
-    for (int i = 0; i < AV1_K_MEANS_DIM; ++i) {
-        const int diff = p1[i] - p2[i];
-        dist += diff * diff;
-    }
+    for (int i = 0; i < AV1_K_MEANS_DIM; ++i) { dist += SQR(p1[i] - p2[i]); }
     return dist;
 }
 
@@ -59,20 +57,28 @@ static INLINE void RENAME(calc_centroids)(const int *data, int *centroids, const
         }
     }
 
-    for (i = 0; i < k; ++i) {
-        if (count[i] == 0) {
-            if (svt_memcpy != NULL)
+    if (svt_memcpy != NULL) {
+        for (i = 0; i < k; ++i) {
+            if (count[i] == 0) {
                 svt_memcpy(centroids + i * AV1_K_MEANS_DIM,
                            data + (lcg_rand16(&rand_state) % n) * AV1_K_MEANS_DIM,
                            sizeof(centroids[0]) * AV1_K_MEANS_DIM);
-            else
+            } else {
+                for (j = 0; j < AV1_K_MEANS_DIM; ++j) {
+                    centroids[i * AV1_K_MEANS_DIM + j] = DIVIDE_AND_ROUND(centroids[i * AV1_K_MEANS_DIM + j], count[i]);
+                }
+            }
+        }
+    } else {
+        for (i = 0; i < k; ++i) {
+            if (count[i] == 0) {
                 svt_memcpy_c(centroids + i * AV1_K_MEANS_DIM,
                              data + (lcg_rand16(&rand_state) % n) * AV1_K_MEANS_DIM,
                              sizeof(centroids[0]) * AV1_K_MEANS_DIM);
-
-        } else {
-            for (j = 0; j < AV1_K_MEANS_DIM; ++j) {
-                centroids[i * AV1_K_MEANS_DIM + j] = DIVIDE_AND_ROUND(centroids[i * AV1_K_MEANS_DIM + j], count[i]);
+            } else {
+                for (j = 0; j < AV1_K_MEANS_DIM; ++j) {
+                    centroids[i * AV1_K_MEANS_DIM + j] = DIVIDE_AND_ROUND(centroids[i * AV1_K_MEANS_DIM + j], count[i]);
+                }
             }
         }
     }
@@ -95,32 +101,42 @@ void RENAME(svt_av1_k_means)(const int *data, int *centroids, uint8_t *indices,
     RENAME(svt_av1_calc_indices)(data, centroids, indices, n, k);
     int64_t this_dist = RENAME(calc_total_dist)(data, centroids, indices, n, k);
 
-    for (int i = 0; i < max_itr; ++i) {
-        const int64_t pre_dist = this_dist;
-        if (svt_memcpy != NULL) {
+    if (svt_memcpy != NULL) {
+        for (int i = 0; i < max_itr; ++i) {
+            const int64_t pre_dist = this_dist;
             svt_memcpy(pre_centroids, centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM);
             svt_memcpy(pre_indices, indices, sizeof(pre_indices[0]) * n);
-        } else {
-            svt_memcpy_c(pre_centroids, centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM);
-            svt_memcpy_c(pre_indices, indices, sizeof(pre_indices[0]) * n);
-        }
 
-        RENAME(calc_centroids)(data, centroids, indices, n, k);
-        RENAME(svt_av1_calc_indices)(data, centroids, indices, n, k);
-        this_dist = RENAME(calc_total_dist)(data, centroids, indices, n, k);
+            RENAME(calc_centroids)(data, centroids, indices, n, k);
+            RENAME(svt_av1_calc_indices)(data, centroids, indices, n, k);
+            this_dist = RENAME(calc_total_dist)(data, centroids, indices, n, k);
 
-        if (this_dist > pre_dist) {
-            if (svt_memcpy != NULL) {
+            if (this_dist > pre_dist) {
                 svt_memcpy(centroids, pre_centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM);
                 svt_memcpy(indices, pre_indices, sizeof(pre_indices[0]) * n);
-            } else {
+                break;
+            }
+            if (!memcmp(centroids, pre_centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM))
+                break;
+        }
+    } else {
+        for (int i = 0; i < max_itr; ++i) {
+            const int64_t pre_dist = this_dist;
+            svt_memcpy_c(pre_centroids, centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM);
+            svt_memcpy_c(pre_indices, indices, sizeof(pre_indices[0]) * n);
+
+            RENAME(calc_centroids)(data, centroids, indices, n, k);
+            RENAME(svt_av1_calc_indices)(data, centroids, indices, n, k);
+            this_dist = RENAME(calc_total_dist)(data, centroids, indices, n, k);
+
+            if (this_dist > pre_dist) {
                 svt_memcpy_c(centroids, pre_centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM);
                 svt_memcpy_c(indices, pre_indices, sizeof(pre_indices[0]) * n);
+                break;
             }
-            break;
+            if (!memcmp(centroids, pre_centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM))
+                break;
         }
-        if (!memcmp(centroids, pre_centroids, sizeof(pre_centroids[0]) * k * AV1_K_MEANS_DIM))
-            break;
     }
 }
 #undef RENAME_
diff --git a/Source/Lib/Codec/product_coding_loop.c b/Source/Lib/Codec/product_coding_loop.c
index f32d4241..ce0df4bd 100644
--- a/Source/Lib/Codec/product_coding_loop.c
+++ b/Source/Lib/Codec/product_coding_loop.c
@@ -11,6 +11,7 @@
 */
 
 #include <stdlib.h>
+#include <stdbool.h>
 
 #include "definitions.h"
 #include "me_sb_results.h"
@@ -69,11 +70,11 @@ static void determine_best_references(PictureControlSet *pcs, ModeDecisionContex
     const uint8_t      total_me_cnt = sb_results->total_me_candidate_index[ctx->me_block_offset];
     const MeCandidate *me_results   = &sb_results->me_candidate_array[ctx->me_cand_offset];
 
-    uint32_t is_last_added     = 0;
-    uint32_t is_bwd_added      = 0;
-    uint32_t is_last_bwd_added = 0;
+    uint8_t is_last_added     = 0;
+    uint8_t is_bwd_added      = 0;
+    uint8_t is_last_bwd_added = 0;
 
-    uint32_t ri = 0;
+    uint16_t ri = 0;
     for (uint8_t me_index = 0; me_index < total_me_cnt; ++me_index) {
         const MeCandidate *cand = &me_results[me_index];
         if (cand->direction == 0) {
@@ -1453,9 +1454,9 @@ void svt_aom_set_nics(NicScalingCtrls *scaling_ctrls, uint32_t mds1_count[CAND_C
     }
 
     // minimum nics allowed
-    uint32_t min_mds1_nics = (pic_type < 2 && scaling_ctrls->stage1_scaling_num) ? 2 : 1;
-    uint32_t min_mds2_nics = (pic_type < 2 && scaling_ctrls->stage2_scaling_num) ? 2 : 1;
-    uint32_t min_mds3_nics = (pic_type < 2 && scaling_ctrls->stage3_scaling_num) ? 2 : 1;
+    uint8_t min_mds1_nics = (pic_type < 2 && scaling_ctrls->stage1_scaling_num) ? 2 : 1;
+    uint8_t min_mds2_nics = (pic_type < 2 && scaling_ctrls->stage2_scaling_num) ? 2 : 1;
+    uint8_t min_mds3_nics = (pic_type < 2 && scaling_ctrls->stage3_scaling_num) ? 2 : 1;
 
     // Set the scaling numerators
     uint32_t stage1_num = scaling_ctrls->stage1_scaling_num;
@@ -2878,10 +2879,9 @@ static Bool get_sb_tpl_inter_stats(PictureControlSet *pcs, ModeDecisionContext *
         const int sb_cols = MAX(1, sb_geom->width / tpl_blk_size);
         const int sb_rows = MAX(1, sb_geom->height / tpl_blk_size);
 
-        uint8_t tot_cnt           = 0;
-        uint8_t inter_cnt         = 0;
-        uint8_t max_list0_ref_idx = 0;
-        uint8_t max_list1_ref_idx = 0;
+        uint8_t tot_cnt             = 0;
+        uint8_t inter_cnt           = 0;
+        uint8_t max_list_ref_idx[2] = {0};
 
         // Loop over all blocks in the SB
         for (int i = 0; i < sb_rows; i++) {
@@ -2897,11 +2897,7 @@ static Bool get_sb_tpl_inter_stats(PictureControlSet *pcs, ModeDecisionContext *
                         ? (tpl_src_stats_buffer->best_rf_idx - 4)
                         : tpl_src_stats_buffer->best_rf_idx;
 
-                    if (list_index)
-                        max_list1_ref_idx = MAX(max_list1_ref_idx, ref_pic_index);
-                    else
-                        max_list0_ref_idx = MAX(max_list0_ref_idx, ref_pic_index);
-
+                    max_list_ref_idx[list_index] = MAX(max_list_ref_idx[list_index], ref_pic_index);
                     inter_cnt++;
                 }
 
@@ -2910,8 +2906,8 @@ static Bool get_sb_tpl_inter_stats(PictureControlSet *pcs, ModeDecisionContext *
         }
 
         *sb_inter_selection   = (inter_cnt * 100) / tot_cnt;
-        *sb_max_list0_ref_idx = max_list0_ref_idx;
-        *sb_max_list1_ref_idx = max_list1_ref_idx;
+        *sb_max_list0_ref_idx = max_list_ref_idx[0];
+        *sb_max_list1_ref_idx = max_list_ref_idx[1];
         return 1;
     }
     return 0;
@@ -3494,7 +3490,7 @@ static void av1_cost_calc_cfl(PictureControlSet *pcs, ModeDecisionCandidateBuffe
 static uint64_t md_cfl_rd_pick_alpha(PictureControlSet *pcs, ModeDecisionCandidateBuffer *cand_bf,
                                      ModeDecisionContext *ctx, EbPictureBufferDesc *input_pic,
                                      uint32_t input_cb_origin_in_index, uint32_t blk_chroma_origin_index,
-                                     int32_t *cfl_alpha_idx, int32_t *cfl_alpha_signs) {
+                                     uint8_t *cfl_alpha_idx, uint8_t *cfl_alpha_signs) {
     uint64_t best_rd = MAX_MODE_COST;
     uint64_t full_dist[DIST_TOTAL][DIST_CALC_TOTAL];
     uint64_t coeff_bits;
@@ -3505,58 +3501,64 @@ static uint64_t md_cfl_rd_pick_alpha(PictureControlSet *pcs, ModeDecisionCandida
         (uint64_t)ctx->md_rate_est_ctx->intra_uv_mode_fac_bits[CFL_ALLOWED][cand_bf->cand->pred_mode][UV_CFL_PRED],
         0);
     uint64_t best_rd_uv[CFL_JOINT_SIGNS][CFL_PRED_PLANES];
-    int32_t  best_c[CFL_JOINT_SIGNS][CFL_PRED_PLANES];
+    uint8_t  best_c[CFL_JOINT_SIGNS][CFL_PRED_PLANES];
 
-    for (int32_t plane = 0; plane < CFL_PRED_PLANES; plane++) {
+    for (uint8_t plane = 0; plane < CFL_PRED_PLANES; plane++) {
         coeff_bits                               = 0;
         full_dist[DIST_SSD][DIST_CALC_RESIDUAL]  = 0;
         full_dist[DIST_SSIM][DIST_CALC_RESIDUAL] = 0;
-        for (int32_t joint_sign = 0; joint_sign < CFL_JOINT_SIGNS; joint_sign++) {
+        for (uint8_t joint_sign = 0; joint_sign < CFL_JOINT_SIGNS; joint_sign++) {
             best_rd_uv[joint_sign][plane] = MAX_MODE_COST;
             best_c[joint_sign][plane]     = 0;
         }
-        // Collect RD stats for an alpha value of zero in this plane.
-        // Skip i == CFL_SIGN_ZERO as (0, 0) is invalid.
-        for (int32_t i = CFL_SIGN_NEG; i < CFL_SIGNS; i++) {
-            const int32_t joint_sign = PLANE_SIGN_TO_JOINT_SIGN(plane, CFL_SIGN_ZERO, i);
-            if (i == CFL_SIGN_NEG) {
-                cand_bf->cand->cfl_alpha_idx   = 0;
-                cand_bf->cand->cfl_alpha_signs = joint_sign;
-
-                av1_cost_calc_cfl(pcs,
-                                  cand_bf,
-                                  ctx,
-                                  (plane == 0) ? COMPONENT_CHROMA_CB : COMPONENT_CHROMA_CR,
-                                  input_pic,
-                                  input_cb_origin_in_index,
-                                  blk_chroma_origin_index,
-                                  full_dist,
-                                  &coeff_bits,
-                                  0);
-
-                if (coeff_bits == INT64_MAX)
-                    break;
-            }
-            const int32_t alpha_rate      = ctx->md_rate_est_ctx->cfl_alpha_fac_bits[joint_sign][plane][0];
-            best_rd_uv[joint_sign][plane] = RDCOST(
-                full_lambda, coeff_bits + alpha_rate, full_dist[DIST_SSD][DIST_CALC_RESIDUAL]);
-        }
-    }
 
-    int32_t best_joint_sign = -1;
-
-    for (int32_t plane = 0; plane < CFL_PRED_PLANES; plane++) {
-        for (int32_t pn_sign = CFL_SIGN_NEG; pn_sign < CFL_SIGNS; pn_sign++) {
-            int32_t progress = 0;
-            for (int32_t c = 0; c < CFL_ALPHABET_SIZE; c++) {
-                int32_t flag = 0;
+        // Collect RD stats for an alpha value of zero in this plane.
+        // Skip CFL_SIGN_ZERO as (0, 0) is invalid.
+        // The two remaining signs are CFL_SIGN_NEG and CFL_SIGN_POS
+        // Collect RD stats for CFL_SIGN_NEG
+        const uint8_t joint_sign_neg   = PLANE_SIGN_TO_JOINT_SIGN(plane, CFL_SIGN_ZERO, CFL_SIGN_NEG);
+        cand_bf->cand->cfl_alpha_idx   = 0;
+        cand_bf->cand->cfl_alpha_signs = joint_sign_neg;
+        // Only caculate cfl cost for joint_sign_neg
+        av1_cost_calc_cfl(pcs,
+                          cand_bf,
+                          ctx,
+                          (plane == 0) ? COMPONENT_CHROMA_CB : COMPONENT_CHROMA_CR,
+                          input_pic,
+                          input_cb_origin_in_index,
+                          blk_chroma_origin_index,
+                          full_dist,
+                          &coeff_bits,
+                          0);
+        if (coeff_bits != INT64_MAX) {
+            // Collect RD stats for CFL_SIGN_NEG
+            const int32_t alpha_rate_neg      = ctx->md_rate_est_ctx->cfl_alpha_fac_bits[joint_sign_neg][plane][0];
+            best_rd_uv[joint_sign_neg][plane] = RDCOST(
+                full_lambda, coeff_bits + alpha_rate_neg, full_dist[DIST_SSD][DIST_CALC_RESIDUAL]);
+
+            // Collect RD stats for CFL_SIGN_POS
+            const uint8_t joint_sign_pos      = PLANE_SIGN_TO_JOINT_SIGN(plane, CFL_SIGN_ZERO, CFL_SIGN_POS);
+            const int32_t alpha_rate_pos      = ctx->md_rate_est_ctx->cfl_alpha_fac_bits[joint_sign_pos][plane][0];
+            best_rd_uv[joint_sign_pos][plane] = RDCOST(
+                full_lambda, coeff_bits + alpha_rate_pos, full_dist[DIST_SSD][DIST_CALC_RESIDUAL]);
+        }
+    }
+
+    uint8_t best_joint_sign       = 0;
+    bool    best_joint_sign_found = false;
+
+    for (uint8_t plane = 0; plane < CFL_PRED_PLANES; plane++) {
+        for (uint8_t pn_sign = CFL_SIGN_NEG; pn_sign < CFL_SIGNS; pn_sign++) {
+            uint8_t progress = 0;
+            for (uint8_t c = 0; c < CFL_ALPHABET_SIZE; c++) {
+                uint8_t flag = 0;
                 if (c > ctx->cfl_ctrls.itr_th && progress < c)
                     break;
                 coeff_bits                               = 0;
                 full_dist[DIST_SSD][DIST_CALC_RESIDUAL]  = 0;
                 full_dist[DIST_SSIM][DIST_CALC_RESIDUAL] = 0;
-                for (int32_t i = 0; i < CFL_SIGNS; i++) {
-                    const int32_t joint_sign = PLANE_SIGN_TO_JOINT_SIGN(plane, pn_sign, i);
+                for (uint8_t i = 0; i < CFL_SIGNS; i++) {
+                    const uint8_t joint_sign = PLANE_SIGN_TO_JOINT_SIGN(plane, pn_sign, i);
                     if (i == 0) {
                         cand_bf->cand->cfl_alpha_idx   = (c << CFL_ALPHABET_SIZE_LOG2) + c;
                         cand_bf->cand->cfl_alpha_signs = joint_sign;
@@ -3589,8 +3591,9 @@ static uint64_t md_cfl_rd_pick_alpha(PictureControlSet *pcs, ModeDecisionCandida
                     this_rd += mode_rd + best_rd_uv[joint_sign][!plane];
                     if (this_rd >= best_rd)
                         continue;
-                    best_rd         = this_rd;
-                    best_joint_sign = joint_sign;
+                    best_rd               = this_rd;
+                    best_joint_sign       = joint_sign;
+                    best_joint_sign_found = true;
                 }
                 progress += flag;
             }
@@ -3598,13 +3601,12 @@ static uint64_t md_cfl_rd_pick_alpha(PictureControlSet *pcs, ModeDecisionCandida
     }
 
     if (best_rd != MAX_MODE_COST) {
-        int32_t ind = 0;
-        if (best_joint_sign >= 0) {
-            const int32_t u = best_c[best_joint_sign][CFL_PRED_U];
-            const int32_t v = best_c[best_joint_sign][CFL_PRED_V];
+        uint8_t ind = 0;
+        if (best_joint_sign_found) {
+            const uint8_t u = best_c[best_joint_sign][CFL_PRED_U];
+            const uint8_t v = best_c[best_joint_sign][CFL_PRED_V];
             ind             = (u << CFL_ALPHABET_SIZE_LOG2) + v;
-        } else
-            best_joint_sign = 0;
+        }
         *cfl_alpha_idx   = ind;
         *cfl_alpha_signs = best_joint_sign;
     }
@@ -3739,7 +3741,7 @@ static void cfl_prediction(PictureControlSet *pcs, ModeDecisionCandidateBuffer *
     compute_cfl_ac_components(ctx, cand_bf);
 
     // Loop over alphas and find the best CFL params
-    int32_t  cfl_alpha_idx = 0, cfl_alpha_signs = 0;
+    uint8_t  cfl_alpha_idx = 0, cfl_alpha_signs = 0;
     uint64_t cfl_rd = md_cfl_rd_pick_alpha(pcs,
                                            cand_bf,
                                            ctx,
diff --git a/Source/Lib/Codec/rc_process.c b/Source/Lib/Codec/rc_process.c
index 512d54c3..1025db89 100644
--- a/Source/Lib/Codec/rc_process.c
+++ b/Source/Lib/Codec/rc_process.c
@@ -544,10 +544,9 @@ static int get_cqp_kf_boost_from_r0(double r0, int frames_to_key, EbInputResolut
         factor = AOMMIN(factor, 10.0);
         factor = AOMMAX(factor, 4.0);
     }
-    const int is_720p_or_smaller = input_resolution <= INPUT_SIZE_720p_RANGE;
-    const int boost              = is_720p_or_smaller ? (int)rint(3 * (75.0 + 17.0 * factor) / r0)
-                                                      : (int)rint(4 * (75.0 + 17.0 * factor) / r0);
-    return boost;
+    // calculate boost based on resolution
+    return input_resolution <= INPUT_SIZE_720p_RANGE ? (int)rint(3 * (75.0 + 17.0 * factor) / r0)
+                                                     : (int)rint(4 * (75.0 + 17.0 * factor) / r0);
 }
 
 double svt_av1_get_gfu_boost_projection_factor(double min_factor, double max_factor, int frame_count) {
@@ -1269,10 +1268,7 @@ void svt_aom_cyclic_refresh_init(PictureParentControlSet *ppcs) {
     SequenceControlSet *scs = ppcs->scs;
     CyclicRefresh      *cr  = &ppcs->cyclic_refresh;
 
-    if ((ppcs->slice_type != I_SLICE) && (ppcs->temporal_layer_index == 0))
-        cr->apply_cyclic_refresh = 1;
-    else
-        cr->apply_cyclic_refresh = 0;
+    cr->apply_cyclic_refresh = ((ppcs->slice_type != I_SLICE) && (ppcs->temporal_layer_index == 0)) ? 1 : 0;
 
     uint16_t sb_cnt     = scs->sb_total_count;
     cr->percent_refresh = 20;
@@ -1291,11 +1287,11 @@ void svt_aom_cyclic_refresh_init(PictureParentControlSet *ppcs) {
     }
     // Use larger delta - qp(increase rate_ratio_qdelta) for first few(~4)
     // periods of the refresh cycle, after a key frame.
-    cr->max_qdelta_perc = 60;
-    if (ppcs->picture_number > (uint64_t)(4 * (1 << scs->max_heirachical_level) * 100 / cr->percent_refresh))
-        cr->rate_ratio_qdelta = 2;
-    else
-        cr->rate_ratio_qdelta = 3;
+    cr->max_qdelta_perc   = 60;
+    cr->rate_ratio_qdelta = (ppcs->picture_number >
+                             (uint64_t)(4 * (1 << scs->max_heirachical_level) * 100 / cr->percent_refresh))
+        ? 2
+        : 3;
     if (ppcs->sc_class1)
         cr->rate_ratio_qdelta += 0.5;
 }
diff --git a/Source/Lib/Codec/temporal_filtering.c b/Source/Lib/Codec/temporal_filtering.c
index 232ffc68..02ef7cf0 100644
--- a/Source/Lib/Codec/temporal_filtering.c
+++ b/Source/Lib/Codec/temporal_filtering.c
@@ -748,10 +748,7 @@ static uint32_t calculate_squared_errors_sum(const uint8_t *s, int s_stride, con
     unsigned int i, j;
     uint32_t     sum = 0;
     for (i = 0; i < h; i++) {
-        for (j = 0; j < w; j++) {
-            const int16_t diff = s[i * s_stride + j] - p[i * p_stride + j];
-            sum += diff * diff;
-        }
+        for (j = 0; j < w; j++) { sum += SQR(s[i * s_stride + j] - p[i * p_stride + j]); }
     }
     return sum;
 }
@@ -763,10 +760,7 @@ static uint32_t calculate_squared_errors_sum_highbd(const uint16_t *s, int s_str
     unsigned int i, j;
     uint32_t     sum = 0;
     for (i = 0; i < h; i++) {
-        for (j = 0; j < w; j++) {
-            const int32_t diff = s[i * s_stride + j] - p[i * p_stride + j];
-            sum += diff * diff;
-        }
+        for (j = 0; j < w; j++) { sum += SQR(s[i * s_stride + j] - p[i * p_stride + j]); }
     }
     return (sum >> shift_factor);
 }
-- 
2.36.0.windows.1

