From 24279a5d9bc00a3eb2227f14aee5cdb7225ae363 Mon Sep 17 00:00:00 2001
From: Salome Thirot <salome.thirot@arm.com>
Date: Wed, 9 Oct 2024 16:42:11 +0100
Subject: [PATCH 11/56] Add Neon implementation of
 svt_av1_filter_intra_edge_high

Port the libaom Neon implementation of svt_av1_filter_intra_edge_high
and add the corresponding unit tests.
---
 Source/Lib/ASM_NEON/CMakeLists.txt            |   1 +
 .../ASM_NEON/highbd_intra_prediction_neon.c   | 167 ++++++++++++++++++
 Source/Lib/Codec/common_dsp_rtcd.c            |   2 +-
 Source/Lib/Codec/common_dsp_rtcd.h            |   1 +
 test/intrapred_edge_filter_test.cc            |   7 +-
 5 files changed, 176 insertions(+), 2 deletions(-)
 create mode 100644 Source/Lib/ASM_NEON/highbd_intra_prediction_neon.c

diff --git a/Source/Lib/ASM_NEON/CMakeLists.txt b/Source/Lib/ASM_NEON/CMakeLists.txt
index 32d1403d..d3880460 100644
--- a/Source/Lib/ASM_NEON/CMakeLists.txt
+++ b/Source/Lib/ASM_NEON/CMakeLists.txt
@@ -39,6 +39,7 @@ target_sources(
   PUBLIC transforms_intrin_neon.c
   PUBLIC hadmard_path_neon.c
   PUBLIC highbd_fwd_txfm_neon.c
+  PUBLIC highbd_intra_prediction_neon.c
   PUBLIC highbd_inv_txfm_neon.c
   PUBLIC highbd_pickrst_neon.c
   PUBLIC highbd_variance_neon.c
diff --git a/Source/Lib/ASM_NEON/highbd_intra_prediction_neon.c b/Source/Lib/ASM_NEON/highbd_intra_prediction_neon.c
new file mode 100644
index 00000000..17e4907b
--- /dev/null
+++ b/Source/Lib/ASM_NEON/highbd_intra_prediction_neon.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2023, Alliance for Open Media. All rights reserved.
+ *
+ * This source code is subject to the terms of the BSD 2 Clause License and
+ * the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
+ * was not distributed with this source code in the LICENSE file, you can
+ * obtain it at www.aomedia.org/license/software. If the Alliance for Open
+ * Media Patent License 1.0 was not distributed with this source code in the
+ * PATENTS file, you can obtain it at www.aomedia.org/license/patent.
+ */
+
+#include <arm_neon.h>
+#include <assert.h>
+
+#include "definitions.h"
+#include "common_dsp_rtcd.h"
+
+void svt_av1_filter_intra_edge_high_neon(uint16_t *p, int sz, int strength) {
+    if (!strength)
+        return;
+    assert(sz >= 0 && sz <= 129);
+
+    DECLARE_ALIGNED(16, static const uint16_t, idx[8]) = {0, 1, 2, 3, 4, 5, 6, 7};
+    const uint16x8_t index                             = vld1q_u16(idx);
+
+    uint16_t edge[160]; // Max value of sz + enough padding for vector accesses.
+    memcpy(edge + 1, p, sz * sizeof(*p));
+
+    // Populate extra space appropriately.
+    edge[0]      = edge[1];
+    edge[sz + 1] = edge[sz];
+    edge[sz + 2] = edge[sz];
+
+    // Don't overwrite first pixel.
+    uint16_t *dst = p + 1;
+    sz--;
+
+    if (strength == 1) { // Filter: {4, 8, 4}.
+        const uint16_t *src = edge + 1;
+
+        while (sz >= 8) {
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+
+            // Make use of the identity:
+            // (4*a + 8*b + 4*c) >> 4 == (a + (b << 1) + c) >> 2
+            uint16x8_t t0  = vaddq_u16(s0, s2);
+            uint16x8_t t1  = vaddq_u16(s1, s1);
+            uint16x8_t sum = vaddq_u16(t0, t1);
+            uint16x8_t res = vrshrq_n_u16(sum, 2);
+
+            vst1q_u16(dst, res);
+
+            src += 8;
+            dst += 8;
+            sz -= 8;
+        }
+
+        if (sz > 0) { // Handle sz < 8 to avoid modifying out-of-bounds values.
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+
+            // Make use of the identity:
+            // (4*a + 8*b + 4*c) >> 4 == (a + (b << 1) + c) >> 2
+            uint16x8_t t0  = vaddq_u16(s0, s2);
+            uint16x8_t t1  = vaddq_u16(s1, s1);
+            uint16x8_t sum = vaddq_u16(t0, t1);
+            uint16x8_t res = vrshrq_n_u16(sum, 2);
+
+            // Mask off out-of-bounds indices.
+            uint16x8_t current_dst = vld1q_u16(dst);
+            uint16x8_t mask        = vcgtq_u16(vdupq_n_u16(sz), index);
+            res                    = vbslq_u16(mask, res, current_dst);
+
+            vst1q_u16(dst, res);
+        }
+    } else if (strength == 2) { // Filter: {5, 6, 5}.
+        const uint16_t *src = edge + 1;
+
+        const uint16x8x3_t filter = {{vdupq_n_u16(5), vdupq_n_u16(6), vdupq_n_u16(5)}};
+        while (sz >= 8) {
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+
+            uint16x8_t accum = vmulq_u16(s0, filter.val[0]);
+            accum            = vmlaq_u16(accum, s1, filter.val[1]);
+            accum            = vmlaq_u16(accum, s2, filter.val[2]);
+            uint16x8_t res   = vrshrq_n_u16(accum, 4);
+
+            vst1q_u16(dst, res);
+
+            src += 8;
+            dst += 8;
+            sz -= 8;
+        }
+
+        if (sz > 0) { // Handle sz < 8 to avoid modifying out-of-bounds values.
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+
+            uint16x8_t accum = vmulq_u16(s0, filter.val[0]);
+            accum            = vmlaq_u16(accum, s1, filter.val[1]);
+            accum            = vmlaq_u16(accum, s2, filter.val[2]);
+            uint16x8_t res   = vrshrq_n_u16(accum, 4);
+
+            // Mask off out-of-bounds indices.
+            uint16x8_t current_dst = vld1q_u16(dst);
+            uint16x8_t mask        = vcgtq_u16(vdupq_n_u16(sz), index);
+            res                    = vbslq_u16(mask, res, current_dst);
+
+            vst1q_u16(dst, res);
+        }
+    } else { // Filter {2, 4, 4, 4, 2}.
+        const uint16_t *src = edge;
+
+        while (sz >= 8) {
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+            uint16x8_t s3 = vld1q_u16(src + 3);
+            uint16x8_t s4 = vld1q_u16(src + 4);
+
+            // Make use of the identity:
+            // (2*a + 4*b + 4*c + 4*d + 2*e) >> 4 == (a + ((b + c + d) << 1) + e) >> 3
+            uint16x8_t t0  = vaddq_u16(s0, s4);
+            uint16x8_t t1  = vaddq_u16(s1, s2);
+            t1             = vaddq_u16(t1, s3);
+            t1             = vaddq_u16(t1, t1);
+            uint16x8_t sum = vaddq_u16(t0, t1);
+            uint16x8_t res = vrshrq_n_u16(sum, 3);
+
+            vst1q_u16(dst, res);
+
+            src += 8;
+            dst += 8;
+            sz -= 8;
+        }
+
+        if (sz > 0) { // Handle sz < 8 to avoid modifying out-of-bounds values.
+            uint16x8_t s0 = vld1q_u16(src);
+            uint16x8_t s1 = vld1q_u16(src + 1);
+            uint16x8_t s2 = vld1q_u16(src + 2);
+            uint16x8_t s3 = vld1q_u16(src + 3);
+            uint16x8_t s4 = vld1q_u16(src + 4);
+
+            // Make use of the identity:
+            // (2*a + 4*b + 4*c + 4*d + 2*e) >> 4 == (a + ((b + c + d) << 1) + e) >> 3
+            uint16x8_t t0  = vaddq_u16(s0, s4);
+            uint16x8_t t1  = vaddq_u16(s1, s2);
+            t1             = vaddq_u16(t1, s3);
+            t1             = vaddq_u16(t1, t1);
+            uint16x8_t sum = vaddq_u16(t0, t1);
+            uint16x8_t res = vrshrq_n_u16(sum, 3);
+
+            // Mask off out-of-bounds indices.
+            uint16x8_t current_dst = vld1q_u16(dst);
+            uint16x8_t mask        = vcgtq_u16(vdupq_n_u16(sz), index);
+            res                    = vbslq_u16(mask, res, current_dst);
+
+            vst1q_u16(dst, res);
+        }
+    }
+}
diff --git a/Source/Lib/Codec/common_dsp_rtcd.c b/Source/Lib/Codec/common_dsp_rtcd.c
index c01bf38d..db454b8d 100644
--- a/Source/Lib/Codec/common_dsp_rtcd.c
+++ b/Source/Lib/Codec/common_dsp_rtcd.c
@@ -1009,7 +1009,7 @@ void svt_aom_setup_common_rtcd_internal(EbCpuFlags flags) {
     SET_NEON(svt_cfl_predict_lbd, svt_cfl_predict_lbd_c, svt_aom_cfl_predict_lbd_neon);
     SET_ONLY_C(svt_cfl_predict_hbd, svt_cfl_predict_hbd_c);
     SET_NEON(svt_av1_filter_intra_predictor, svt_av1_filter_intra_predictor_c, svt_av1_filter_intra_predictor_neon);
-    SET_ONLY_C(svt_av1_filter_intra_edge_high, svt_av1_filter_intra_edge_high_c);
+    SET_NEON(svt_av1_filter_intra_edge_high, svt_av1_filter_intra_edge_high_c, svt_av1_filter_intra_edge_high_neon);
     SET_NEON(svt_av1_filter_intra_edge, svt_av1_filter_intra_edge_c, svt_av1_filter_intra_edge_neon);
     SET_ONLY_C(svt_av1_upsample_intra_edge, svt_av1_upsample_intra_edge_c);
     SET_ONLY_C(svt_av1_build_compound_diffwtd_mask_d16, svt_av1_build_compound_diffwtd_mask_d16_c);
diff --git a/Source/Lib/Codec/common_dsp_rtcd.h b/Source/Lib/Codec/common_dsp_rtcd.h
index 8524c539..3b4113e8 100644
--- a/Source/Lib/Codec/common_dsp_rtcd.h
+++ b/Source/Lib/Codec/common_dsp_rtcd.h
@@ -1161,6 +1161,7 @@ extern "C" {
     void svt_av1_selfguided_restoration_neon(const uint8_t *dat8, int32_t width, int32_t height, int32_t stride, int32_t *flt0, int32_t *flt1, int32_t flt_stride, int32_t sgr_params_idx, int32_t bit_depth, int32_t highbd);
 
     void svt_av1_filter_intra_edge_neon(uint8_t *p, int32_t sz, int32_t strength);
+    void svt_av1_filter_intra_edge_high_neon(uint16_t *p, int32_t sz, int32_t strength);
 
     void svt_av1_dr_prediction_z1_neon(uint8_t *dst, ptrdiff_t stride, int32_t bw, int32_t bh, const uint8_t *above, const uint8_t *left,int32_t upsample_above, int32_t dx, int32_t dy);
     void svt_av1_dr_prediction_z2_neon(uint8_t *dst, ptrdiff_t stride, int32_t bw, int32_t bh, const uint8_t *above, const uint8_t *left, int32_t upsample_above, int32_t upsample_left, int32_t dx,int32_t dy);
diff --git a/test/intrapred_edge_filter_test.cc b/test/intrapred_edge_filter_test.cc
index e1dc1fde..3dcdc6ba 100644
--- a/test/intrapred_edge_filter_test.cc
+++ b/test/intrapred_edge_filter_test.cc
@@ -258,7 +258,6 @@ class HighbdFilterEdgeTest : public FilterEdgeTest<uint16_t, FILTER_EDGE_HBD> {
         bd_ = 10;
     }
 };
-GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(HighbdFilterEdgeTest);
 
 TEST_P(HighbdFilterEdgeTest, RunTest) {
     RunTest();
@@ -269,4 +268,10 @@ INSTANTIATE_TEST_SUITE_P(
     SSE4_1, HighbdFilterEdgeTest,
     ::testing::Values(svt_av1_filter_intra_edge_high_sse4_1));
 #endif  // ARCH_X86_64
+
+#if ARCH_AARCH64
+INSTANTIATE_TEST_SUITE_P(
+    NEON, HighbdFilterEdgeTest,
+    ::testing::Values(svt_av1_filter_intra_edge_high_neon));
+#endif  // ARCH_AARCH64
 }  // namespace
-- 
2.36.0.windows.1

