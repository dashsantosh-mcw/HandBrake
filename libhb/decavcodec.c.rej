diff a/libhb/decavcodec.c b/libhb/decavcodec.c	(rejected hunks)
@@ -1423,6 +1448,21 @@ static int decodeFrame( hb_work_private_t * pv, packet_info_t * packet_info )
     return got_picture;
 }
 
+static enum AVPixelFormat get_hw_format(AVCodecContext *s, const enum AVPixelFormat *pix_fmts)
+{
+    hb_work_private_t *pv = s->opaque;
+    const enum AVPixelFormat *p;
+
+    for (p = pix_fmts; *p != -1; p++)
+    {
+        if (*p == pv->hw_pix_fmt)
+            return *p;
+    }
+
+    hb_error( "Failed to get HW surface format\n" );
+    return AV_PIX_FMT_NONE;
+}
+
 static int decavcodecvInit( hb_work_object_t * w, hb_job_t * job )
 {
 
@@ -1517,6 +1557,45 @@ static int decavcodecvInit( hb_work_object_t * w, hb_job_t * job )
     pv->context->err_recognition = AV_EF_CRCCHECK;
     pv->context->error_concealment = FF_EC_GUESS_MVS|FF_EC_DEBLOCK;
 
+    if ( job && job->hwaccel_decode )
+    {
+        enum AVHWDeviceType hw_type = av_hwdevice_find_type_by_name("d3d11va");
+        pv->hw_pix_fmt = AV_PIX_FMT_NONE;
+        if (hw_type != AV_HWDEVICE_TYPE_NONE) {
+            int i;
+            for (i = 0;; i++)
+            {
+                const AVCodecHWConfig *config = avcodec_get_hw_config(pv->codec, i);
+                if (!config)
+                    break;
+                if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&
+                    config->device_type == hw_type)
+                {
+                    pv->hw_pix_fmt = config->pix_fmt;
+                    break;
+                }
+            }
+        }
+        if (pv->hw_pix_fmt != AV_PIX_FMT_NONE)
+        {
+            AVBufferRef *hw_device_ctx;
+            int err;
+            if ((err = av_hwdevice_ctx_create(&hw_device_ctx, hw_type, NULL, NULL, 0)) < 0) {
+                hb_error( "decavcodecvInit: failed to create hwdevice" );
+            } else {
+                pv->context->get_format = get_hw_format;
+                pv->context->opaque = pv;
+                pv->context->hw_device_ctx = hw_device_ctx;
+                pv->hw_frame = av_frame_alloc();
+                if (pv->hw_frame == NULL)
+                {
+                    hb_log("decavcodecvInit: av_frame_alloc failed");
+                    return 1;
+                }
+            }
+        }
+    }
+
     if ( pv->title->opaque_priv )
     {
         AVFormatContext *ic = (AVFormatContext*)pv->title->opaque_priv;
@@ -2160,7 +2240,23 @@ static int decavcodecvInfo( hb_work_object_t *w, hb_work_info_t *info )
     info->color_range    = pv->context->color_range;
 
     info->video_decode_support = HB_DECODE_SUPPORT_SW;
-
+    hw_type = av_hwdevice_find_type_by_name("d3d11va");
+    if (hw_type != AV_HWDEVICE_TYPE_NONE)
+    {
+        int i;
+        for (i = 0;; i++)
+        {
+            const AVCodecHWConfig *config = avcodec_get_hw_config(pv->context->codec, i);
+            if (!config)
+                break;
+            if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX &&
+                config->device_type == hw_type)
+            {
+                info->video_decode_support |= HB_DECODE_SUPPORT_HWACCEL;
+                break;
+            }
+        }
+    }
 #if HB_PROJECT_FEATURE_QSV
     if (hb_qsv_available())
     {
